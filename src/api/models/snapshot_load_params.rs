// Firecracker API
//
// RESTful public-facing API. The API is accessible through HTTP calls on specific URLs carrying
// JSON modeled data. The transport medium is a Unix Domain Socket.
//
// OpenAPI spec version: 1.2.0
// Contact: compute-capsule@amazon.com
// Generated by: https://github.com/swagger-api/swagger-codegen.git

/// SnapshotLoadParams : Defines the configuration used for handling snapshot resume. Exactly
/// one of the two `mem_*` fields must be present in the body of the request.
use super::MemoryBackend;

use serde_derive::{Deserialize, Serialize};

#[derive(Debug, Serialize, Deserialize)]
pub struct SnapshotLoadParams {
    /// Enable support for incremental (diff) snapshots by tracking dirty guest pages.
    #[serde(rename = "enable_diff_snapshots")]
    enable_diff_snapshots: Option<bool>,
    /// Path to the file that contains the guest memory to be loaded. This parameter has been
    /// deprecated and is only allowed if `mem_backend` is not present.
    #[serde(rename = "mem_file_path")]
    mem_file_path: Option<String>,
    /// Configuration for the backend that handles memory load. If this field is specified,
    /// `mem_file_path` is forbidden. Either `mem_backend` or `mem_file_path` must be present at a
    /// time.
    #[serde(rename = "mem_backend")]
    mem_backend: Option<MemoryBackend>,
    /// Path to the file that contains the microVM state to be loaded.
    #[serde(rename = "snapshot_path")]
    snapshot_path: String,
    /// When set to true, the vm is also resumed if the snapshot load is successful.
    #[serde(rename = "resume_vm")]
    resume_vm: Option<bool>,
}

impl SnapshotLoadParams {
    /// Defines the configuration used for handling snapshot resume. Exactly one of the two `mem_*`
    /// fields must be present in the body of the request.
    pub fn new(snapshot_path: String) -> SnapshotLoadParams {
        SnapshotLoadParams {
            enable_diff_snapshots: None,
            mem_file_path: None,
            mem_backend: None,
            snapshot_path,
            resume_vm: None,
        }
    }

    pub fn set_enable_diff_snapshots(&mut self, enable_diff_snapshots: bool) {
        self.enable_diff_snapshots = Some(enable_diff_snapshots);
    }

    pub fn with_enable_diff_snapshots(mut self, enable_diff_snapshots: bool) -> SnapshotLoadParams {
        self.enable_diff_snapshots = Some(enable_diff_snapshots);
        self
    }

    pub fn enable_diff_snapshots(&self) -> Option<&bool> {
        self.enable_diff_snapshots.as_ref()
    }

    pub fn reset_enable_diff_snapshots(&mut self) {
        self.enable_diff_snapshots = None;
    }

    pub fn set_mem_file_path(&mut self, mem_file_path: String) {
        self.mem_file_path = Some(mem_file_path);
    }

    pub fn with_mem_file_path(mut self, mem_file_path: String) -> SnapshotLoadParams {
        self.mem_file_path = Some(mem_file_path);
        self
    }

    pub fn mem_file_path(&self) -> Option<&String> {
        self.mem_file_path.as_ref()
    }

    pub fn reset_mem_file_path(&mut self) {
        self.mem_file_path = None;
    }

    pub fn set_mem_backend(&mut self, mem_backend: MemoryBackend) {
        self.mem_backend = Some(mem_backend);
    }

    pub fn with_mem_backend(mut self, mem_backend: MemoryBackend) -> SnapshotLoadParams {
        self.mem_backend = Some(mem_backend);
        self
    }

    pub fn mem_backend(&self) -> Option<&MemoryBackend> {
        self.mem_backend.as_ref()
    }

    pub fn reset_mem_backend(&mut self) {
        self.mem_backend = None;
    }

    pub fn set_snapshot_path(&mut self, snapshot_path: String) {
        self.snapshot_path = snapshot_path;
    }

    pub fn with_snapshot_path(mut self, snapshot_path: String) -> SnapshotLoadParams {
        self.snapshot_path = snapshot_path;
        self
    }

    pub fn snapshot_path(&self) -> &String {
        &self.snapshot_path
    }

    pub fn set_resume_vm(&mut self, resume_vm: bool) {
        self.resume_vm = Some(resume_vm);
    }

    pub fn with_resume_vm(mut self, resume_vm: bool) -> SnapshotLoadParams {
        self.resume_vm = Some(resume_vm);
        self
    }

    pub fn resume_vm(&self) -> Option<&bool> {
        self.resume_vm.as_ref()
    }

    pub fn reset_resume_vm(&mut self) {
        self.resume_vm = None;
    }
}
